var documenterSearchIndex = {"docs":
[{"location":"api/#Blosc2.jl-Main-API","page":"Main API","title":"Blosc2.jl Main API","text":"","category":"section"},{"location":"api/#Compressors","page":"Main API","title":"Compressors","text":"","category":"section"},{"location":"api/","page":"Main API","title":"Main API","text":"Compressor\navailable_compressors\navailable_compressors_names\nhas_compressor\ncompressor_by_name\ndefault_compressor\ndefault_compressor_name","category":"page"},{"location":"api/#Blosc2.Compressor","page":"Main API","title":"Blosc2.Compressor","text":"Compressor\n\nRepresentation of compressor supprted by blosc\n\n\n\n\n\n","category":"type"},{"location":"api/#Blosc2.available_compressors","page":"Main API","title":"Blosc2.available_compressors","text":"available_compressors()::Dict{Symbol, Compressor}\n\nGet dictionary of available compressors\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.available_compressors_names","page":"Main API","title":"Blosc2.available_compressors_names","text":"available_compressors_names()::Vector{Symbol}\n\nGet vector of available compressors names\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.has_compressor","page":"Main API","title":"Blosc2.has_compressor","text":"has_compressor(name::Symbol)\n\nCheck if compressor name available\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.compressor_by_name","page":"Main API","title":"Blosc2.compressor_by_name","text":"compressor(name::Symbol)\n\nGet compressor by name\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.default_compressor","page":"Main API","title":"Blosc2.default_compressor","text":"default_compressor()\n\nDefault compressor\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.default_compressor_name","page":"Main API","title":"Blosc2.default_compressor_name","text":"default_compressor_name()\n\nName of default compressor\n\n\n\n\n\n","category":"function"},{"location":"api/#Filters","page":"Main API","title":"Filters","text":"","category":"section"},{"location":"api/","page":"Main API","title":"Main API","text":"has_filter\navailable_filter_names\nfilter_description\nfilter_pipeline","category":"page"},{"location":"api/#Blosc2.has_filter","page":"Main API","title":"Blosc2.has_filter","text":"has_filter(name::Symbol)\n\nCheck if filter with name name is exists\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.available_filter_names","page":"Main API","title":"Blosc2.available_filter_names","text":"available_filter_names()\n\nGet vector with names of available filters\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.filter_description","page":"Main API","title":"Blosc2.filter_description","text":"filter_description(name::Symbol)\n\nGet desctription of filter name\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.filter_pipeline","page":"Main API","title":"Blosc2.filter_pipeline","text":"filter_pipeline(args...)\n\nMake filter pipeline. Each argument can be filter name (Symbol) or pair name=>meta ('Pair{Symbol, Integer}'). Each argument represents a filter in a chain of filters that are sequentially applied during compression Maximum number of filters is max_filters_count()\n\nExamples\n\nfilter_pipeline(:trunc_prec=>23, :shuffle)\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilites","page":"Main API","title":"Utilites","text":"","category":"section"},{"location":"api/","page":"Main API","title":"Main API","text":"sizes\nuncompressed_sizeof\nuncompressed_length\ncompressed_sizeof","category":"page"},{"location":"api/#Blosc2.sizes","page":"Main API","title":"Blosc2.sizes","text":"sizes(buff::Vector{UInt8}, offset = 1)\n\nGet information about a compressed buffer at offset offset (1-indexed), as Tuple with values:\n\nthe number of uncompressed bytes\nthe number of compressed bytes\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.uncompressed_sizeof","page":"Main API","title":"Blosc2.uncompressed_sizeof","text":"uncompressed_sizof(buff::Vector{UInt8}, offset = 1)\n\nUncompressed size of data in buffer buff in bytes`\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.uncompressed_length","page":"Main API","title":"Blosc2.uncompressed_length","text":"uncompressed_length(::Type{T}, buff::Vector{UInt8}, offset = 1)\n\nUncompressed length of Vector{T} then decompressed from buffer buff\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.compressed_sizeof","page":"Main API","title":"Blosc2.compressed_sizeof","text":"compressed_sizeof(buff::Vector{UInt8}, offset = 1)\n\nCompressed size of data in buffer buff in bytes\n\n\n\n\n\n","category":"function"},{"location":"api/#API-for-compression/decompression","page":"Main API","title":"API for compression/decompression","text":"","category":"section"},{"location":"api/","page":"Main API","title":"Main API","text":"CompressionParams\nDecompressionParams\nContext\nCompressionContext\nDecompressionContext\nmax_compression_overhead\nmax_compressed_size\nmake_compress_buffer\nunsafe_compress!\ncompress!\ncompress\nunsafe_decompress!\ndecompress!\ndecompress\ndecompress_items!","category":"page"},{"location":"api/#Blosc2.CompressionParams","page":"Main API","title":"Blosc2.CompressionParams","text":"CompressionParams\n\nCompression params\n\nCompressionParams(;\n    compressor ::Symbol = default_compressor_name()\n    level ::UInt8 = 5\n    typesize ::Int32 = 8\n    nthreads ::Int32 = 1\n    blocksize ::Int32 = 0\n    splitmode ::Bool = false\n    filter_pipeline ::FilterPipeline = filter_pipeline(:shuffle)\n)\n\nCreate compression parameters\n\nArguments\n\ncompressor::Symbol - The name of compressor to use\nlevel - The compression level from 0 (no compression) to 9 (maximum compression)\ntypesize - The size of type being compressed\nnthreads - The number of threads to use internally\nblocksize - The requested size of the compressed blocks (0 means auto)\nsplitmode - Whether the blocks should be split or not.\nfilter_pipeline - Filters pipeline\n\n\n\n\n\n","category":"type"},{"location":"api/#Blosc2.DecompressionParams","page":"Main API","title":"Blosc2.DecompressionParams","text":"DecompressionParams\n\nDecompression params\n\nDecomplessionParams(;nthreads = 1)\n\nCreate decompression parameters\n\n\n\n\n\n","category":"type"},{"location":"api/#Blosc2.Context","page":"Main API","title":"Blosc2.Context","text":"Context{T <: Params}\nCompressionContext = Context{CompressionParams}\nDecompressionContext = Context{DecompressionParams}\n\nConstructors\n\nContext{T}(params::T) where {T <: Params}\n\nCreate context.\n\nIf params is CompressionParams then this is CompressionContext\nIf params is DecompressionParams then this is DecompressionContext\n\nCompressionContext(;kwargs...)\n\nCreate compression context kwargs passed to CompressionParams constructor\n\nDecompressionContext(;kwargs...)\n\nCreate decompression context kwargs passed od DecompressionParams consturctor\n\n\n\n\n\n","category":"type"},{"location":"api/#Blosc2.CompressionContext","page":"Main API","title":"Blosc2.CompressionContext","text":"CompressionContext(::Type{T}; kwargs...)\n\nCreate CompressionContext for compressing vectors with element type T. This is equivalent to CompressionContext(CompressionParams(T; kwargs...))`\n\n\n\n\n\n","category":"type"},{"location":"api/#Blosc2.DecompressionContext","page":"Main API","title":"Blosc2.DecompressionContext","text":"Context{T <: Params}\nCompressionContext = Context{CompressionParams}\nDecompressionContext = Context{DecompressionParams}\n\nConstructors\n\nContext{T}(params::T) where {T <: Params}\n\nCreate context.\n\nIf params is CompressionParams then this is CompressionContext\nIf params is DecompressionParams then this is DecompressionContext\n\nCompressionContext(;kwargs...)\n\nCreate compression context kwargs passed to CompressionParams constructor\n\nDecompressionContext(;kwargs...)\n\nCreate decompression context kwargs passed od DecompressionParams consturctor\n\n\n\n\n\n","category":"type"},{"location":"api/#Blosc2.max_compression_overhead","page":"Main API","title":"Blosc2.max_compression_overhead","text":"max_compression_overhead()\n\nThe maximum overhead during compression in bytes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.max_compressed_size","page":"Main API","title":"Blosc2.max_compressed_size","text":"max_compressed_size(src)\n\nThe maximum size after compression in bytes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.make_compress_buffer","page":"Main API","title":"Blosc2.make_compress_buffer","text":"max_compress_buffer(src)\n\nCreates a buffer that is guaranteed to contain compressed data\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.unsafe_compress!","page":"Main API","title":"Blosc2.unsafe_compress!","text":"unsafe_compress!([ctx = CompressionContext(T; kwargs...)], dest::Ptr{T}, dest_size, src::Ptr{T}, src_size; kwargs...)\n\nCompress src_size bytes from src buffer, into dest buffer (with dest_size bytes size) using context ctx with no checks, return size of the data written to dest\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointers dest and src to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.compress!","page":"Main API","title":"Blosc2.compress!","text":"compress!([ctx = CompressionContext(T; kwargs...)],\n     dest::Vector{UInt8}, src::Vector{T},\n     [dest_offset = 1], [src_range = 1:length(src)]\n    ; kwargs...\n    )\n\nCompress elements from  src_range of src into dest buffer starting from dest_offset (1-indexed) using context ctx Return size of the data written to dest\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.compress","page":"Main API","title":"Blosc2.compress","text":"compress([ctx = CompressionContext(T; kwargs...)], src::Array{T}, [src_range = 1:length(src)]; kwargs...)::Vector{UInt8}\n\nReturn Vector{UInt8} consisting of src_range of src in compressed form using context ctx\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.unsafe_decompress!","page":"Main API","title":"Blosc2.unsafe_decompress!","text":"unsafe_decompress!([ctx = DecompressionContext(;kwargs...)], dest::Ptr{T}, dest_size, src::Ptr{UInt8}, src_size; kwargs...)\n\nDecompress data from src buffer, into dest buffer using context ctx with no checks, return count of elements written to dest or negative value if an error. dest_size and src_size are the byte sizes of buffers dest and src respectively\n\nReturn count of the elements written to dest\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointers dest and src to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.decompress!","page":"Main API","title":"Blosc2.decompress!","text":"decompress!([ctx = DecompressionContext(;kwargs...)], dest::Vector{T}, src::Vector{UInt8}, dest_offset = 1, src_offset = 1; kwargs...)\n\nDecompress data from buffer src at offset src_offset (1-indexed) into vector dest at offset dest_offset (1-indexed). Return count of the elements written to dest\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.decompress","page":"Main API","title":"Blosc2.decompress","text":"decompress([ctx = DecompressionContext(kwargs...)], ::Type{T}, src::Array{UInt8}, [src_offset = 1]; kwargs...)::Vector{T}\n\nReturn Vector{T} consisting of decompression data from src starting at src_offset using context ctx\n\n\n\n\n\n","category":"function"},{"location":"api/#Blosc2.decompress_items!","page":"Main API","title":"Blosc2.decompress_items!","text":"decompress_items!(ctx::DecompressionContext, dest::Vector{T},  src::Vector{UInt8}, range::UnitRange{<:Integer}, dest_offset, src_offset)\n\nDecompress items in range from buffer src at offset src_offset (1-indexed) into vector dest at offset dest_offset (1-indexed). Return count of the elements written to dest\n\n\n\n\n\n","category":"function"},{"location":"lib/#Low-level-interface-api","page":"Low Level API","title":"Low level interface api","text":"","category":"section"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"Direct low-level interfaces to the c library placed in submodule Lib","category":"page"},{"location":"lib/#Blosc1-API","page":"Low Level API","title":"Blosc1 API","text":"","category":"section"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"This is the classic API from Blosc1 with 32-bit limited containers. Corresponding c-blosc2 documentation","category":"page"},{"location":"lib/#Main-API","page":"Low Level API","title":"Main API","text":"","category":"section"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"Lib.blosc_init\nLib.blosc_destroy\nLib.blosc_compress\nLib.blosc_decompress\nLib.blosc_getitem\nLib.blosc_get_nthreads\nLib.blosc_set_nthreads\nLib.blosc_get_compressor\nLib.blosc_set_compressor\nLib.blosc_set_delta\nLib.blosc_set_blocksize\nLib.blosc_free_resources","category":"page"},{"location":"lib/#Blosc2.Lib.blosc_init","page":"Low Level API","title":"Blosc2.Lib.blosc_init","text":"blosc_init()\n\nInitialize the Blosc library environment.\n\nYou must call this previous to any other Blosc call, unless you want Blosc to be used simultaneously in a multi-threaded environment, in which case you can use the blosc2compressctx blosc2decompressctx pair.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_destroy","page":"Low Level API","title":"Blosc2.Lib.blosc_destroy","text":"blosc_destroy()\n\nDestroy the Blosc library environment.\n\nYou must call this after to you are done with all the Blosc calls, unless you have not used blosc_init() before.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_compress","page":"Low Level API","title":"Blosc2.Lib.blosc_compress","text":"blosc_compress(level, shuffle, itemsize, srcsize, src, dest, destsize)\n\nCompress a block of data in the src buffer and returns the size of compressed block.\n\nC signature: int blosc_compress(int clevel, int doshuffle, size_t typesize, size_t nbytes, const void *src, void *dest, size_t destsize)`\n\nArguments\n\nclevel - The desired compression level and must be a number           between 0 (no compression) and 9 (maximum compression).\ndoshuffle - Specifies whether the shuffle compression preconditioner   should be applied or not. BLOSC_NOFILTER means not applying filters,   BLOSC_SHUFFLE means applying shuffle at a byte level and   BLOSC_BITSHUFFLE at a bit level (slower but may achieve better   compression).\ntypesize - Is the number of bytes for the atomic type in binary   src` buffer.  This is mainly useful for the shuffle preconditioner.   For implementation reasons, only a 1 < typesize < 256 will allow the   shuffle filter to work.  When typesize is not in this range, shuffle   will be silently disabled.\nnbytes - The number of bytes to compress in the src buffer.\nsrc -  The buffer containing the data to compress.\ndest  - The buffer where the compressed data will be put,   must have at least the size of destsize.\ndestsize -  The size of the dest buffer. Blosc   guarantees that if you set destsize to, at least,   BLOSC_MAX_OVERHEAD, the compression will always succeed.\n\nReturns\n\nThe number of bytes compressed. If src buffer cannot be compressed into destsize, the return value is zero and you should discard the contents of the dest buffer.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_decompress","page":"Low Level API","title":"Blosc2.Lib.blosc_decompress","text":"blosc_decompress(src, dest, destsize)\n\nDecompress a block of compressed data in src, put the result in dest and returns the size of the decompressed block.\n\nC signature: int blosc_decompress(const void *src, void *dest, size_t destsize)\n\nArguments\n\nsrc  - The buffer to be decompressed.\ndest - The buffer where the decompressed data will be put.\ndestsize = The size of the @p dest buffer\n\nReturns\n\nThe number of bytes decompressed. If an error occurs, e.g. the compressed data is corrupted or the output buffer is not large enough, then a negative value will be returned instead.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_getitem","page":"Low Level API","title":"Blosc2.Lib.blosc_getitem","text":"blosc_getitem(src, start, nitems, dest)\n\nGet nitems (of typesize size) in src buffer starting in start. The items are returned in dest buffer, which has to have enough space for storing all items.\n\nC signature: int blosc_getitem(const void *src, int start, int nitems, void *dest)\n\n#Arguments\n\nsrc - The compressed buffer from data will be decompressed.\nstart - The zero-indexed position of the first item (of typesize size) from where data will be retrieved.\nnitems - The number of items (of typesize size) that will be retrieved.\ndest -  The buffer where the decompressed data retrieved will be put.\n\nReturns\n\nThe number of bytes copied to @p dest or a negative value if some error happens.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_get_nthreads","page":"Low Level API","title":"Blosc2.Lib.blosc_get_nthreads","text":"blosc_get_nthreads()\n\nReturns the current number of threads that are used for compression/decompression.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_set_nthreads","page":"Low Level API","title":"Blosc2.Lib.blosc_set_nthreads","text":"blosc_set_nthreads(nthreads)\n\nInitialize a pool of threads for compression/decompression. If nthreads is 1, then the serial version is chosen and a possible previous existing pool is ended. If this is not called, nthreads is set to 1 internally.\n\nReturns\n\nThe previous number of threads.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_get_compressor","page":"Low Level API","title":"Blosc2.Lib.blosc_get_compressor","text":"blosc_get_compressor()\n\nGet the current compressor that is used for compression.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_set_compressor","page":"Low Level API","title":"Blosc2.Lib.blosc_set_compressor","text":"blosc_set_compressor(compname::AbstractString)\n\nSelect the compressor to be used.\n\nThe supported ones are “blosclz”, “lz4”, “lz4hc”, “zlib” and “ztsd”. If this function is not called, then “blosclz” will be used.\n\n#Returns\n\nThe code for the compressor (>=0). In case the compressor is not recognized, or there is not support for it in this build, it returns a -1.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_set_delta","page":"Low Level API","title":"Blosc2.Lib.blosc_set_delta","text":"blosc_set_delta(dodelta)\n\nSelect the delta coding filter to be used.\n\nThis call should always succeed.\n\n#Arguments\n\ndodelta – A value >0 will activate the delta filter. If 0, it will be de-activated\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_set_blocksize","page":"Low Level API","title":"Blosc2.Lib.blosc_set_blocksize","text":"blosc_set_blocksize(blocksize)\n\nForce the use of a specific blocksize.\n\nIf 0, an automatic blocksize will be used (the default).\n\nWarning\n\nThe blocksize is a critical parameter with important restrictions in the allowed values, so use this with care.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_free_resources","page":"Low Level API","title":"Blosc2.Lib.blosc_free_resources","text":"blosc_free_resources()\n\nFree possible memory temporaries and thread resources.\n\nUse this when you are not going to use Blosc for a long while.\n\nReturns\n\nA 0 if succeeds, in case of problems releasing the resources, it returns a negative number.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Compressed-buffer-information","page":"Low Level API","title":"Compressed buffer information","text":"","category":"section"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"Lib.blosc_cbuffer_sizes\nLib.blosc_cbuffer_metainfo\nLib.blosc_cbuffer_versions\nLib.blosc_cbuffer_complib","category":"page"},{"location":"lib/#Blosc2.Lib.blosc_cbuffer_sizes","page":"Low Level API","title":"Blosc2.Lib.blosc_cbuffer_sizes","text":"blosc_cbuffer_sizes(cbuffer)::NamedTuple{(:nbytes, :cbytes, blocksize), Tuple{Int, Int, Int}}\n\nGet information about a compressed buffer, namely the number of uncompressed bytes (nbytes) and compressed (cbytes).\n\nIt also returns the blocksize (which is used internally for doing the compression by blocks).\n\nYou only need to pass the first BLOSCEXTENDEDHEADER_LENGTH bytes of a compressed buffer for this call to work.\n\nThis function should always succeed.\n\nC signature void blosc_cbuffer_sizes(const void *cbuffer, size_t *nbytes, size_t *cbytes, size_t *blocksize)\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_cbuffer_metainfo","page":"Low Level API","title":"Blosc2.Lib.blosc_cbuffer_metainfo","text":"blosc_cbuffer_metainfo(cbuffer)::NamedTuple{(:typesize, :flags), Tuple{Int, Int}}\n\nGet information about a compressed buffer, namely the type size (typesize), as well as some internal flags.\n\nYou can use the BLOSC_DOSHUFFLE, BLOSC_DOBITSHUFFLE, BLOSC_DODELTA and BLOSC_MEMCPYED symbols for extracting the interesting bits (e.g. flags & BLOSC_DOSHUFFLE says whether the buffer is byte-shuffled or not).\n\nThis function should always succeed.\n\nC signature void blosc_cbuffer_metainfo(const void *cbuffer, size_t *typesize, int *flags)\n\nflags bits:\n\nbit 0: whether the shuffle filter has been applied or not\nbit 1: whether the internal buffer is a pure memcpy or not\nbit 2: whether the bitshuffle filter has been applied or not\nbit 3: whether the delta coding filter has been applied or not\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_cbuffer_versions","page":"Low Level API","title":"Blosc2.Lib.blosc_cbuffer_versions","text":"blosc_cbuffer_versions(cbuffer)::NamedTuple{(:version, :versionlz), Tuple{Int, Int}}\n\nGet information about a compressed buffer, namely the internal Blosc format version (version) and the format for the internal Lempel-Ziv compressor used (versionlz).\n\nThis function should always succeed.\n\nC signature void blosc_cbuffer_versions(const void *cbuffer, int *version, int *versionlz)\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_cbuffer_complib","page":"Low Level API","title":"Blosc2.Lib.blosc_cbuffer_complib","text":"blosc_cbuffer_complib(cbuffer)\n\nGet the compressor library/format used in a compressed buffer.\n\nThis function should always succeed.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Utility-functions","page":"Low Level API","title":"Utility functions","text":"","category":"section"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"Lib.blosc_compcode_to_compname\nLib.blosc_compname_to_compcode\nLib.blosc_list_compressors\nLib.blosc_get_version_string\nLib.blosc_get_complib_info","category":"page"},{"location":"lib/#Blosc2.Lib.blosc_compcode_to_compname","page":"Low Level API","title":"Blosc2.Lib.blosc_compcode_to_compname","text":"blosc_compcode_to_compname(compcode)\n\nGet the compressor name associated with the compressor code.\n\nC signature int blosc_compcode_to_compname(int compcode, const char **compname)\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_compname_to_compcode","page":"Low Level API","title":"Blosc2.Lib.blosc_compname_to_compcode","text":"blosc_compname_to_compcode(compname)\n\nGet the compressor code associated with the compressor name.\n\nReturns\n\nThe compressor code. If the compressor name is not recognized, or there is not support for it in this build, -1 is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_list_compressors","page":"Low Level API","title":"Blosc2.Lib.blosc_list_compressors","text":"blosc_list_compressors()\n\nGet a list of compressors supported in the current build.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_get_version_string","page":"Low Level API","title":"Blosc2.Lib.blosc_get_version_string","text":"blosc_get_version_string()\n\nGet the version of Blosc in string format.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc_get_complib_info","page":"Low Level API","title":"Blosc2.Lib.blosc_get_complib_info","text":"blosc_get_complib_info(compname)::NamedTuple{(:code, :complib, :version), Tuple{Int, String, String}}\n\nGet info from compression libraries included in the current build.\n\nReturns\n\nNamedTuple with following fields:\n\ncode for the compression library (>=0), if it is not supported, then -1\ncomplib – The string where the compression library name, if available, else empty string\nversion – The string where the compression library version, if available, else empty string\n\nC signature int blosc_get_complib_info(const char *compname, char **complib, char **version)\n\n\n\n\n\n","category":"function"},{"location":"lib/#Context","page":"Low Level API","title":"Context","text":"","category":"section"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"In Blosc 2 there is a special blosc2_context struct that is created from compression and decompression parameters. This allows the compression and decompression to happen in multithreaded scenarios, without the need for using the global lock. Corresponding c-blosc2 documentation","category":"page"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"Lib.blosc2_cparams\nLib.blosc2_dparams\nLib.blosc2_context\nLib.blosc2_create_cctx\nLib.blosc2_create_dctx\nLib.blosc2_free_ctx\nLib.blosc2_compress_ctx\nLib.blosc2_decompress_ctx\nLib.blosc2_getitem_ctx\nLib.blosc2_set_maskout\nLib.blosc2_ctx_get_cparams\nLib.blosc2_ctx_get_dparams","category":"page"},{"location":"lib/#Blosc2.Lib.blosc2_cparams","page":"Low Level API","title":"Blosc2.Lib.blosc2_cparams","text":"blosc2_cparams\n\nThe parameters for creating a context for compression purposes.\n\nIn parenthesis it is shown the default value used internally when a 0 (zero) in the fields of the struct is passed to a function.\n\npreffiler must match blosc2prefilterfn defenition: typedef int (blosc2prefilterfn)(blosc2prefilterparams params);\n\n\n\n\n\n","category":"type"},{"location":"lib/#Blosc2.Lib.blosc2_dparams","page":"Low Level API","title":"Blosc2.Lib.blosc2_dparams","text":"blosc2_dparams\n\nThe parameters for creating a context for decompression purposes. In parenthesis it is shown the default value used internally when a 0 (zero) in the fields of the struct is passed to a function.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Blosc2.Lib.blosc2_context","page":"Low Level API","title":"Blosc2.Lib.blosc2_context","text":"blosc2_context\n\nContext opaque object\n\n\n\n\n\n","category":"type"},{"location":"lib/#Blosc2.Lib.blosc2_create_cctx","page":"Low Level API","title":"Blosc2.Lib.blosc2_create_cctx","text":"blosc2_create_cctx(cparams::blosc2_cparams = blosc2_cparams())\n\nCreate a context for *_ctx() compression functions.\n\nReturns\n\nA pointer to the new context. NULL is returned if this fails.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_create_dctx","page":"Low Level API","title":"Blosc2.Lib.blosc2_create_dctx","text":"blosc2_create_dctx(dparams::blosc2_dparams = blosc2_dparams())\n\nCreate a context for *_ctx() decompression functions.\n\nReturns\n\nA pointer to the new context. NULL is returned if this fails.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_free_ctx","page":"Low Level API","title":"Blosc2.Lib.blosc2_free_ctx","text":"blosc2_free_ctx(context::Ptr{blosc2_context})\n\nFree the resources associated with a context.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_compress_ctx","page":"Low Level API","title":"Blosc2.Lib.blosc2_compress_ctx","text":"blosc2_compress_ctx(ctx::Ptr{blosc2_context}, src, srcsize, dest, destsize)\n\nContext interface to Blosc compression.\n\nThis does not require a call to blosc_init and can be called from multithreaded applications without the global lock being used, so allowing Blosc be executed simultaneously in those scenarios.\n\nParameters\n\ncontext – A blosc2_context struct with the different compression params.\nsrc – The buffer containing the data to be compressed.\nsrcsize – The number of bytes to be compressed from the src buffer.\ndest – The buffer where the compressed data will be put.\ndestsize – The size in bytes of the dest buffer.\n\nReturns The number of bytes compressed. If src buffer cannot be compressed into destsize, the return value is zero and you should discard the contents of the dest buffer. A negative return value means that an internal error happened. It could happen that context is not meant for compression (which is stated in stderr). Otherwise, please report it back together with the buffer data causing this and compression settings.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_decompress_ctx","page":"Low Level API","title":"Blosc2.Lib.blosc2_decompress_ctx","text":"blosc2_decompress_ctx(ctx::Ptr{blosc2_context}, src, srcsize, dest, destsize)\n\nContext interface to Blosc decompression.\n\nThis does not require a call to blosc_init and can be called from multithreaded applications without the global lock being used, so allowing Blosc be executed simultaneously in those scenarios.\n\nReturns\n\nThe number of bytes copied to dest or a negative value if some error happens.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_getitem_ctx","page":"Low Level API","title":"Blosc2.Lib.blosc2_getitem_ctx","text":"blosc2_getitem_ctx(ctx::Ptr{blosc2_context}, src, srcsize, start, nitems, dest, destsize)\n\nContext interface counterpart for Lib.blosc_getitem.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_set_maskout","page":"Low Level API","title":"Blosc2.Lib.blosc2_set_maskout","text":"blosc2_set_maskout(ctx::Ptr{blosc2_context}, maskout, nblocks)\n\nSet a maskout so as to avoid decompressing specified blocks.\n\nRemark\n\nThe maskout is valid for contexts only meant for decompressing a chunk via blosc2_decompress_ctx. Once a call to blosc2_decompress_ctx is done, this mask is reset so that next call to blosc2_decompress_ctx will decompress the whole chunk.\n\nParameters\n\nctx – The decompression context to update.\nmaskout – The boolean mask for the blocks where decompression is to be avoided.\nnblocks – The number of blocks in maskout above.\n\nReturns If success, a 0 values is returned. An error is signaled with a negative int.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_ctx_get_cparams","page":"Low Level API","title":"Blosc2.Lib.blosc2_ctx_get_cparams","text":"blosc2_ctx_get_cparams(ctx::Ptr{blosc2_context})\n\nCreate a cparams associated to a context.\n\nReturns\n\nblosc2_cparams if succeeds. Else nothing\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_ctx_get_dparams","page":"Low Level API","title":"Blosc2.Lib.blosc2_ctx_get_dparams","text":"blosc2_ctx_get_dparams(ctx::Ptr{blosc2_context})\n\nCreate a dparams associated to a context.\n\nReturns\n\nblosc2_cdarams if succeeds. Else nothing\n\n\n\n\n\n","category":"function"},{"location":"lib/#Super-chunk","page":"Low Level API","title":"Super-chunk","text":"","category":"section"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"This API describes the new Blosc 2 container, the super-chunk (or schunk for short). Corresponding c-blosc2 documentation","category":"page"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"Lib.blosc2_cparams\nLib.blosc2_schunk\nLib.blosc2_schunk_new\nLib.blosc2_schunk_free\nLib.blosc2_schunk_append_buffer\nLib.blosc2_schunk_decompress_chunk\nLib.blosc2_schunk_get_chunk\nLib.blosc2_schunk_append_chunk\nLib.blosc2_schunk_insert_chunk\nLib.blosc2_schunk_update_chunk\nLib.blosc2_schunk_delete_chunk\nLib.blosc2_schunk_reorder_offsets\nLib.blosc2_schunk_get_cparams\nLib.blosc2_schunk_get_dparams","category":"page"},{"location":"lib/#Blosc2.Lib.blosc2_schunk","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk","text":"blosc2_schunk\n\nThis struct is the standard container for Blosc 2 compressed data.\n\nThis is essentially a container for Blosc 1 chunks of compressed data, and it allows to overcome the 32-bit limitation in Blosc 1. Optionally, a blosc2_frame can be attached so as to store the compressed chunks contiguously.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_new","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_new","text":"blosc2_schunk_new(storage::blosc2_storage)::Ptr{blosc2_storage}\n\nCreate a new super-chunk.\n\nRemark\n\nIn case that storage.urlpath is not NULL, the data is stored on-disk. If the data file(s) exist, they are overwritten.\n\nParameters\n\nstorage – The storage properties.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_free","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_free","text":"blosc2_schunk_free(schunk::blosc2_schunk)\n\nRelease resources from a super-chunk.\n\nRemark\n\nAll the memory resources attached to the super-frame are freed. If the super-chunk is on-disk, the data continues there for a later re-opening.\n\nReturns\n\n0 if success\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_append_buffer","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_append_buffer","text":"blosc2_schunk_append_buffer(schunk::Ptr{blosc2_schunk}, src, nbytes)\n\nAppend a src data buffer to a super-chunk.\n\nParameters\n\nschunk – The super-chunk where data will be appended.\nsrc – The buffer of data to compress.\nnbytes – The size of the src buffer.\n\nReturns\n\nThe number of chunks in super-chunk. If some problem is detected, this number will be negative.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_decompress_chunk","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_decompress_chunk","text":"blosc2_schunk_decompress_chunk(schunk::Ptr{blosc2_schunk}, nchunk, dest, nbytes)\n\nDecompress and return the nchunk chunk of a super-chunk.\n\nIf the chunk is uncompressed successfully, it is put in the dest\n\nArguments\n\nschunk – The super-chunk from where the chunk will be decompressed.\nnchunk – The chunk to be decompressed (0 indexed).\ndest – The buffer where the decompressed data will be put.\nnbytes – The size of the dest.\n\nReturns\n\nThe size of the decompressed chunk or 0 if it is non-initialized. If some problem is detected, a negative code is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_get_chunk","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_get_chunk","text":"blosc2_schunk_get_chunk(schunk::Ptr{blosc2_schunk}, nchunk)::Vector{UInt8}\n\nReturn a compressed chunk that is part of a super-chunk in the chunk parameter.\n\nArguments\n\nschunk – The super-chunk from where to extract a chunk.\nnchunk – The chunk to be extracted (0 indexed).\n\nC signature int blosc2_schunk_get_chunk(blosc2_schunk *schunk, int nchunk, uint8_t **chunk, bool *needs_free)\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_append_chunk","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_append_chunk","text":"blosc2_schunk_append_chunk(schunk::Ptr{blosc2_schunk}, chunk, copy)\n\nAppend an existing chunk o a super-chunk.\n\nArguments\n\nschunk – The super-chunk where the chunk will be appended.\nchunk – The chunk to append. An internal copy is made, so chunk can be reused or freed if desired.\ncopy – Whether the chunk should be copied internally or can be used as-is.\n\n#Returns\n\nThe number of chunks in super-chunk. If some problem is detected, this number will be negative.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_insert_chunk","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_insert_chunk","text":"blosc2_schunk_insert_chunk(schunk::Ptr{blosc2_schunk}, nchunk, chunk, copy)\n\nInsert a chunk at a specific position in a super-chunk.\n\nArguments\n\nschunk – The super-chunk where the chunk will be appended.\nnchunk – The position where the chunk will be inserted.(zero indexed)\nchunk – The chunk to insert. If an internal copy is made, the chunk can be reused or freed if desired.\ncopy – Whether the chunk should be copied internally or can be used as-is.\n\nReturns\n\nThe number of chunks in super-chunk. If some problem is detected, this number will be negative.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_update_chunk","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_update_chunk","text":"blosc2_schunk_update_chunk(schunk::ptr{blosc2_schunk}, nchunk, chunk, copy)\n\nUpdate a chunk at a specific position in a super-chunk.\n\nArguments\n\nschunk – The super-chunk where the chunk will be updated.\nnchunk – The position where the chunk will be updated.(zero indexed)\nchunk – The new chunk. If an internal copy is made, the chunk can be reused or freed if desired.\ncopy – Whether the chunk should be copied internally or can be used as-is.\n\nReturns\n\nThe number of chunks in super-chunk. If some problem is detected, this number will be negative.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_delete_chunk","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_delete_chunk","text":"blosc2_schunk_delete_chunk(schunk::ptr{blosc2_schunk}, nchunk)\n\nDelete a chunk at a specific position in a super-chunk.\n\nParameters\n\nschunk – The super-chunk where the chunk will be deleted.\nnchunk – The position where the chunk will be deleted. (zero indexed)\n\nReturns\n\nThe number of chunks in super-chunk. If some problem is detected, this number will be negative.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_reorder_offsets","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_reorder_offsets","text":"blosc2_schunk_reorder_offsets(schunk::Ptr{blosc2_schunk}, offsets_order::Vector{Int32})\n\nReorder the chunk offsets of an existing super-chunk.\n\nArguments\n\nschunk – The super-chunk whose chunk offsets are to be reordered.\noffsets_order – The new order of the chunk offsets (zero ordered)\n\nReturns\n\n0 if suceeds. Else a negative code is returned.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_get_cparams","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_get_cparams","text":"blosc2_schunk_get_cparams(schunk::Ptr{blosc2_schunk})\n\nReturn the cparams associated to a super-chunk.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_schunk_get_dparams","page":"Low Level API","title":"Blosc2.Lib.blosc2_schunk_get_dparams","text":"blosc2_schunk_get_dparams(schunk::Ptr{blosc2_schunk})\n\nReturn the dparams associated to a super-chunk.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Metalayers","page":"Low Level API","title":"Metalayers","text":"","category":"section"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"Metalayers are meta-information that can be attached to super-chunks. They can also be serialized to disk. Corresponding c-blosc2 documentation","category":"page"},{"location":"lib/","page":"Low Level API","title":"Low Level API","text":"Lib.blosc2_meta_exists\nLib.blosc2_meta_add\nLib.blosc2_meta_update\nLib.blosc2_meta_get\nLib.blosc2_vlmeta_exists\nLib.blosc2_vlmeta_add\nLib.blosc2_vlmeta_update\nLib.blosc2_vlmeta_get","category":"page"},{"location":"lib/#Blosc2.Lib.blosc2_meta_exists","page":"Low Level API","title":"Blosc2.Lib.blosc2_meta_exists","text":"blosc2_meta_exists(schunk::Ptr{blosc2_schunk}, name)\n\nFind whether the schunk has a metalayer or not.\n\nArguments\n\nschunk – The super-chunk from which the metalayer will be checked.\nname – The name of the metalayer to be checked.\n\nReturns\n\nIf successful, return the index of the metalayer. Else, return a negative value.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_meta_add","page":"Low Level API","title":"Blosc2.Lib.blosc2_meta_add","text":"blosc2_meta_add(schunk::Ptr{blosc2_schunk}, name, content, content_len)\n\nAdd content into a new metalayer.\n\nArguments\n\nschunk – The super-chunk to which the metalayer should be added.\nname – The name of the metalayer.\ncontent – The content of the metalayer.\ncontent_len – The length of the content.\n\nReturns\n\nIf successful, the index of the new metalayer. Else, return a negative value.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_meta_update","page":"Low Level API","title":"Blosc2.Lib.blosc2_meta_update","text":"blosc2_meta_update(schunk::Ptr{blosc2_schunk}, name, content, content_len)\n\nUpdate the content of an existing metalayer.\n\nArguments\n\nschunk – The frame containing the metalayer.\nname – The name of the metalayer to be updated.\ncontent – The new content of the metalayer.\ncontent_len – The length of the content.\n\nReturns\n\nIf successful, the index of the metalayer. Else, return a negative value.\n\nNote\n\nContrarily to blosc2_meta_add the updates to metalayers are automatically serialized into a possible attached frame.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_meta_get","page":"Low Level API","title":"Blosc2.Lib.blosc2_meta_get","text":"blosc2_meta_get(schunk::Ptr{blosc2_schunk}, name)\n\nGet the content out of a  metalayer.\n\nArguments\n\nschunk – The frame containing the metalayer.\nname – The name of the metalayer to be updated.\ncontent – The new content of the metalayer.\ncontent_len – The length of the content.\n\nReturns\n\nIf successful, the content of the metalayer. Else, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_vlmeta_exists","page":"Low Level API","title":"Blosc2.Lib.blosc2_vlmeta_exists","text":"blosc2_vmeta_exists(schunk::Ptr{blosc2_schunk}, name)\n\nFind whether the schunk has a variable-length metalayer or not.\n\nArguments\n\nschunk – The super-chunk from which the metalayer will be checked.\nname – The name of the metalayer to be checked.\n\nReturns\n\nIf successful, return the index of the metalayer. Else, return a negative value.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_vlmeta_add","page":"Low Level API","title":"Blosc2.Lib.blosc2_vlmeta_add","text":"blosc2_vmeta_add(schunk::Ptr{blosc2_schunk}, name, content, content_len, cparams::blosc2_cparams)\n\nAdd content into a new variable-length metalayer.\n\nArguments\n\nschunk – The super-chunk to which the metalayer should be added.\nname – The name of the metalayer.\ncontent – The content of the metalayer.\ncontent_len – The length of the content.\ncparams – The parameters for compressing the variable-length metalayer content.\n\nReturns\n\nIf successful, the index of the new metalayer. Else, return a negative value.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_vlmeta_update","page":"Low Level API","title":"Blosc2.Lib.blosc2_vlmeta_update","text":"blosc2_vlmeta_update(schunk::Ptr{blosc2_schunk}, name, content, content_len)\n\nUpdate the content of an existing variable-length metalayer.\n\nArguments\n\nschunk – The frame containing the metalayer.\nname – The name of the metalayer to be updated.\ncontent – The new content of the metalayer.\ncontent_len – The length of the content.\ncparams – The parameters for compressing the variable-length metalayer content.\n\nReturns\n\nIf successful, the index of the metalayer. Else, return a negative value.\n\nNote\n\nContrarily to blosc2_meta_add the updates to metalayers are automatically serialized into a possible attached frame.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Blosc2.Lib.blosc2_vlmeta_get","page":"Low Level API","title":"Blosc2.Lib.blosc2_vlmeta_get","text":"blosc2_vlmeta_get(schunk::Ptr{blosc2_schunk}, name)\n\nGet the content out of a variable-length metalayer.\n\nArguments\n\nschunk – The frame containing the metalayer.\nname – The name of the metalayer to be updated.\ncontent – The new content of the metalayer.\ncontent_len – The length of the content.\n\nReturns\n\nIf successful, the content of the metalayer. Else, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"#Blosc2.jl","page":"Introduction","title":"Blosc2.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia interface for the Blosc2 Library","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/waralex/Blosc2.jl.git\"))","category":"page"},{"location":"#Status","page":"Introduction","title":"Status","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The project is in  development.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently, low-level interfaces to the c library are implemented. Compression/decompression functions are also implemented. In the near future, I plan to work with super-chunks, meta layers, as well as more detailed documentation, examples, etc.","category":"page"}]
}
